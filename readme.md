## 서울생활인구

서울생활인구 프로젝트는 2018년 8월 27일부터 2018년 9월 2일까지 서울 특정지역, 특정시간에 존재한 인구(생활인구)를 행정구역별로 정리하여 웹지도 형태로 보여준다.

👉 [프로젝트 바로가기](https://seoul-population-by-time.netlify.com/)

👉 데이터 출처: [서울열린데이터광장/서울생활인구](http://data.seoul.go.kr/dataVisual/seoul/seoulLivingPopulation.do)

### 프로젝트의 시작

맨하탄 유동 인구를 시각화한 [Manhattan Population Explorer](http://manpopex.us/) 프로젝트의 움짤을 본 것이 이 프로젝트를 시작하게 된 계기였다. 나는 사실 데이터를 보이는대로 북마크해놓고 쓸 데는 나중에 생각하자는 식의 데이타 호더러인데, 서울도 유동인구 관련 데이터가 어디엔가 있었는데... 뭐였더라 하고 의식의 흐름을 따라따라 되짚어 보니 [서울의 생활인구 데이터 개방 관련](https://twitter.com/beingsince/status/969746505132228608) 소식을 트위터에서 들었던 기억이 났다.

💡 그래 이 데이터를 써야겠어! 💡

### 개발일지

대략의 개발 과정은 다음과 같다.

1. 서울 행정구 셰이프 데이터를 이용해서 각 구의 중간점에 위치한 육각형을 딴다.
2. 일주일치 생활인구 데이터를 시간대별로 파싱해서 프론트엔드 페이지에서 바로 소비될 수 있는 형태로 가공한다.
3. 브라우저내 스크립트로 인터페이스/애니메이션을 구현한다.

1은  해당 스크립트를 링크하는 것으로 대신한다.

#### 데이터 텍스쳐를 이용한 애니메이션 구현

처음 계획은 한 달치 데이터 중 한 주 분량의 데이터를 뽑은 후, 각 구의 중심 육각형과 합쳐 하나의 json (geojson) 오브젝트를 만들 생각이었다. 대충의 얼개를 써보자면 다음과 같다.
```
properties: {
    code: 111101111,
    population_data: {
        2018090100: {total: -, ...},
        2018090101: {total: -, ...},
        ...
    }
}, geometries: {
    육각형 polygon geometries...
}
```
이런 방식으로 가공된 데이터는 용량이 크기도 제법 크기도 했지만 더 큰 문제는 애니메이션이 ... *느려!!* 딱히 벤치마킹을 하지 않아도 알아차릴 수 있을 정도로 애니메이션의 프레임이 떨어지고, 렌더링 엔진이 업데이트하는 바그래프의 수가 많을 때(지도가 줌아웃되서 많은 그래프가 한 번에 보일 때)와 업데이트하는 바그래프의 수가 적을 때의 퍼포먼스가 눈에 띄게 차이가 났다.

이번 프로젝트에 지도 전용 3D 렌더링 엔진인 탠그램을 사용했는데, 변수 업데이트 후 이 변수를 탠그램에 패스하고, 탠그램이 이 변수를 기반으로 지도를 다시 그리는 방식은 일회성 이벤트(버튼 등의  UI 이벤트에 따라 다른 데이터를 보여주거나 색상등의 속성 업데이트)를 구현하기엔 나쁘지 않지만, 순차적인 애니메이션을 만들기는 적합하지 않다는 것을 제대로 확인할 수 있는 기회였다. 하지만 나는 포기하지 앙아.. 나는 탠그램을 이용해서 구현한 버어터리 스무스한 애니메이션을 본 적이 있다고! 그래서 기억을 더듬고 더듬어 몇 년 전 동료 Patricio Gonzalez Vivo가 실험적으로 구현했던 프로젝트를 찾아냈다.

- [Weather Over Time](https://github.com/tangrams/WeatherOverTime/) by Patricio Gonzalez Vivo

Weather Over Time은 기상청 데이터에 기반하여 한 달 간의 기온, 풍향, 풍속을 시각화한 프로젝트인데 이 프로젝트에서 애니메이션에 접근한 방법은 다음과 같다.

- 데이터를 파싱하여 PNG 이미지로 옮긴다. (Weather Over Time의 경우 기온을 R channel, 풍향을  G channel, 풍속을 B channel로 옮겼다.)
- 데이터가 인코딩된 이미지를 해당 데이터 레이어의 셰이더에 텍스쳐로 패스한다.
- 브라우저내 스크립트는 데이터를 바로 업데이트 하는 대신 셰이더 텍스처의 인덱스를 업데이트한다.

서울생활인구 프로젝트에 데이터 텍스쳐 전략을 적용하기 위해서 찔끔찔끔 공부해왔던 셰이더 지식을 싹싹 긁어모아야 했는데, 어설프게나마 이해한 부분을 정리해보자면

- 셰이더는 픽셀이 사용자에게 어떻게 보이는지를 조절할 수 있는 3D 렌더링 엔진 내의 작은 프로그램이다.
- 셰이더는 하드웨어를 (GPU)를 가속, 각 픽셀마다의 프로세싱을 동시에 진행하면서 (parallel processing) 렌더링 퍼포먼스를 향상한다.
- 셰이더는 모양을 담당하는 vertex shader와 색을 담당하는 fragment shader로 나뉜다. vertex shader가 먼저 실행된 후 fragment shader가 실행된다. (따라서 vertex shader에는 pixel의 색 속성에 대한 정보가 없다.)
- 탠그램을 이용하여 사용자는 각각의 레이어에 해당하는 셰이더를 커스톰 할 수 있다.
- 데이터를 셰이더가 이용할 텍스쳐(이미지)로 가공한 후 레이어가 사용할 텍스쳐로 지정하면, cpu가 할 일을 gpu에게 넘겨주는 셈..이 된다.

🦄 셰이더를 이해하는 데 [Book of Shader](https://thebookofshaders.com/01/)가 큰 도움이 되었다.

셰이더를 이용하기 위해 2.의 과정으로 돌아가 데이터를 png 이미지로 재가공해야했는데 생활인구 데이터 텍스쳐와 주거인구 데이터 텍스쳐를 비교해보면 데이터 텍스쳐가 엔진 내에서 어떻게 소비되는지 대충 감이 온다. (각각의 행정구를 세로축, 시간을 가록축으로 생각하고 각각의 픽셀 값을 생활인구 데이터라고 생각하면 하나의 그래프처럼 읽을 수 있다. 픽셀 값이 하얀 색일 때(rgb 채널이 모두 최고값에 가까울 때) 해당 지역, 시간의 인구 수가 많고, 어두운 색일 떄 (rgb채널 값이 최저값에 가까울 떄) 적다.)

- 생활인구

![생활인구 데이터 텍스쳐](https://raw.githubusercontent.com/hanbyul-here/seoul-population-by-time/master/data/20180827/total.png)

- 주거인구 (시간에 따라 데이터가 변하지 않으므로 열의 색깔이 바뀌지 않는다.)

![주거인구 데이터 텍스쳐](https://raw.githubusercontent.com/hanbyul-here/seoul-population-by-time/master/data/residents.png)

 🚧 작업중입니다. 🚧